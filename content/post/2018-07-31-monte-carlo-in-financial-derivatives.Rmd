---
title: Monte Carlo In Financial Derivatives
author: Yuantong Li
date: '2018-07-31'
slug: monte-carlo-in-financial-derivatives
categories:
  - Finance
  - Monte Carlo
tags:
  - Finance
  - Monte Carlo
description: ''
topics: []
---


# 1. How to estimate Pi with Python

```{python}
#library(reticulate)
from random import random
from math import pow, sqrt

simulations = 5000
hits = 0.0

for x in xrange(simulations):
    x = random() #0 <= x <= 1
    y = random()
    
    #distance to (0,0)
    dist = sqrt(pow(x,2) + pow(y,2))
    
    if dist <= 1:
        hits += 1

print(4 * hits/simulations)
```


# 2. Pricing Options using Monte Carlo

A geometric Brownian motion is a random process where the logarithm of the random variable follows a normal distribution. This type of process distributes prices over a lognormal distribution.

So now we have a method for calculating asset prices at time $T$:

$$S_T = S_t e^{(r-\frac{\sigma^2}{2})(T - t)+ \sigma\epsilon\sqrt{T - t}}$$

where $\epsilon \sim N(0,1)$.

```{python}
import numpy as np
import datetime

def generate_asset_price(S,sigma,r,T):
    return S * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * np.random.normal(0,1))

def call_payoff(S_T,K):
    return max(0,S_T-K)


S = 800 # underlying price
sigma = 0.20 # vol of 20%
r = 0.014 # rate of 1.4%
T = (datetime.date(2018,1,1) - datetime.date(2017,1,1)).days / 365.0
K = 860 

simulations = 100000
payoffs = []
discount_factor = np.exp(-r * T)

for i in xrange(simulations):
    S_T = generate_asset_price(S,sigma,r, T)
    payoffs.append(call_payoff(S_T,K))
    
price = discount_factor * (sum(payoffs)/float(simulations))

print 'Price: %.4f' % price
```

# 3. Price Binary option

```{python}
import random
from math import exp, sqrt

def generate_asset_price(S,sigma,r,T):
    return S * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * np.random.normal(0,1))

def binary_call_payoff(K, S_T):
    if S_T >= K:
        return 1.0
    else:
        return 0.0

# parameters
S = 40.0 # asset price
sigma = 0.2 # vol of 20%
r = 0.01 # rate of 1%
maturity = 0.5
K = 40.0 # ATM strike
simulations = 50000
payoffs = 0.0

# run simultaion
for i in xrange(simulations):
    S_T = generate_asset_price(S, sigma, r, maturity)
    payoffs += binary_call_payoff(K, S_T)

# find prices
option_price = exp(-r * maturity) * (payoffs / float(simulations))

print 'Price: %.8f' % option_price
```

# 4. Measuring Volatility

There are two types of volatility we can consider: implied and realised. Implied volatility can be extracted from option prices (it's implied from the prices). Realised volatility is the actual volatility experienced by the underlying, which could be a stock, futures contract, etc.

*Simple estimation*

$$\sigma^2  = \frac{1}{N-1}\sum^{N}_{i=1}(x_i - \bar{x})^2$$

where $x_i$ is the i'th log return, defined as:
$$x_i = \ln(\frac{S_i}{S_{i-1}})$$

$$\sigma_{annual} = \sigma_{daily} \sqrt{252}$$

*Bias & efficiency*

(1) Use higher frequency data, such as intraday prices.


(2) Use a better estimator.(such like highest or lowest)
   

[_The Parkinson Estimator_](http://breakingdownfinance.com/finance-topics/risk-management/parkinson-volatility/)



# 5. Implied Volatility

Use Newton's method:

```{python}
from scipy.stats import norm
import random
from math import exp, sqrt
import datetime
import numpy as np

def find_vol(target_value, call_put, S, K, T, r):
    MAX_ITERATIONS = 100
    PRECISION = 1.0e-5
    
    sigma = 0.5
    for i in xrange(0, MAX_ITERATIONS):
        price = bs_price(call_put, S, K, T, r, sigma)
        vega = bs_vega(call_put, S,K, T, r, sigma)
        
        price = price
        diff = target_value - price
        
        print(i, sigma, diff)
        
        if(abs(diff) < PRECISION):
            return sigma
        sigma = sigma + diff/vega # f(x)/f'(x)
        
    # value wasn't found, return best guess so far
    return sigma
    
    
    
n = norm.pdf
N = norm.cdf

def bs_price(cp_flag, S, K, T, r, v, q=0.0):

    d1 = (np.log(S/K)+(r+v**2/2.0)*T)/(v*sqrt(T))
    d2 = d1 - v*sqrt(T)
    
    if cp_flag == 'c':
        price = S * exp(-q*T) * N(d1) - K * exp(-r*T) * N(d2)
    else:
        price = K * exp(-r*T) * N(-d2) - S * exp(-q*T) * N(-d1)
        
    return price

def bs_vega(cp_flag, S,K,T,r,v,q=0.0):
    d1 = (np.log(S/K)+(r+v**2/2.0)*T)/(v*sqrt(T))
    return S * sqrt(T) * n(d1)


V_market = 17.5
K = 585
T = (datetime.date(2014,10,18) - datetime.date(2014,9,8)).days / 365.
S = 586.08
r = 0.0002
cp = 'c' # call option

implied_vol = find_vol(V_market, cp, S, K, T, r)

print 'Implied vol: %.2f%%' % (implied_vol * 100)

print 'Market price = %.2f' % V_market
print 'Model price = %.2f' % bs_price(cp, S, K, T, r, implied_vol)
```


# 6. Delta-hedged portfolio





